# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S-UXuOhoLzmUEy-_APEGieucoR_bIQsq
"""

import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import scipy.stats as stats

import random
from scipy.stats import binom
from scipy.stats import poisson
from scipy.stats import norm

#To get information about the dataset

data = pd.read_csv(r"C:\Users\ROHAN KUMAR\Downloads\Spotify.csv")
data.head()

data.info()

data.describe()

sns.pairplot(data)
plt.show()

data.head(20)

data = pd.DataFrame({
    'track_album_release_date': [
        '14-06-2019', '13-12-2019'
    ],
    'track_popularity': [
        66, 67
    ]
})

# Convert the 'track_album_release_date' column to a datetime format
data['track_album_release_date'] = pd.to_datetime(data['track_album_release_date'], format='%d-%m-%Y')

# Create a line plot
plt.figure(figsize=(10, 5))
plt.plot(data['track_album_release_date'], data['track_popularity'], marker='o', linestyle='-')
plt.xlabel('Release Date')
plt.ylabel('Track Popularity')
plt.title('Track Popularity Over Time (Sample)')
plt.grid(True)
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Create a DataFrame with the provided data
data = pd.DataFrame({
    'track_popularity': [
        66, 67, 70, 60, 69, 67, 62, 69, 68, 67, 58, 67, 67, 68, 63, 66, 60, 65, 69, 35
    ]
})
# Create a histogram using Seaborn
plt.figure(figsize=(10, 5))
sns.histplot(data=data, x='track_popularity', bins=10, kde=True)
plt.xlabel('Track Popularity')
plt.ylabel('Frequency')
plt.title('Track Popularity Histogram (Seaborn)')
plt.grid(True)
plt.show()

data.head()

plt.figure(figsize=(10, 6))

sales_channel_profit = data.groupby('playlist_genre')['track_popularity'].mean()
sales_channel_profit.plot(kind='pie', autopct='%1.1f%%', startangle=90)

plt.title('Average Track Popularity by Playlist Genre', fontsize=14, weight='bold')

plt.axis('equal')

plt.show()

top_artists = data.groupby('track_artist')['track_popularity'].mean().nlargest(10)
top_artists.plot(kind='bar', figsize=(10, 6), color='skyblue')

plt.xlabel('Track Artist', fontsize=12, labelpad=10, weight='bold')
plt.ylabel('Average Popularity', fontsize=12, labelpad=10, weight='bold')

plt.title('Top 10 Track Artists by Average Popularity', fontsize=14, weight='bold')

plt.xticks(rotation=45)

plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()

numerical_columns = data.select_dtypes(include=['float64', 'int64'])

plt.figure(figsize=(12, 10))

correlation_matrix = numerical_columns.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='viridis', fmt=".2f")

plt.title('Correlation Heatmap')
plt.show()

#Descriptive Statistics

mean = data['track_popularity'].mean()
median = data['track_popularity'].median()
mode = data['track_popularity'].mode()
range_val = data['track_popularity'].max() - data['track_popularity'].min()
std_dev = np.std(data['track_popularity'])
skewness = data['track_popularity'].skew()
kurtosis = data['track_popularity'].kurt()

# Printing the results
print('Mean of track popularity:', mean)
print('Median of track popularity:', median)
print('Mode of track popularity:', mode)
print('Range of track popularity:', range_val)
print('Standard deviation of track popularity:', std_dev)
print('Skewness of track popularity:', skewness)
print('Kurtosis of track popularity:', kurtosis)

import pandas as pd

# Assuming your DataFrame is named 'data'
grouped_data = data.groupby(["playlist_genre", "key"])
summed_data = grouped_data.sum()

# Display the result
print(summed_data)

duration_ms = data['duration_ms']

mean = duration_ms.mean()
median = duration_ms.median()
mode = duration_ms.mode()[0]

range_val = duration_ms.max() - duration_ms.min()
variance = duration_ms.var()
std_dev = duration_ms.std()
q1 = duration_ms.quantile(0.25)
q3 = duration_ms.quantile(0.75)
iqr = q3 - q1

skewness = duration_ms.skew()
kurtosis = duration_ms.kurtosis()

print(f"Measures of Central Tendency:")
print(f"Mean: {mean}")
print(f"Median: {median}")
print(f"Mode: {mode}\n")

print(f"Measures of Variability:")
print(f"Range: {range_val}")
print(f"Variance: {variance}")
print(f"Standard Deviation: {std_dev}")
print(f"IQR: {iqr}\n")

print(f"Shape of the Distribution:")
print(f"Skewness: {skewness}")
print(f"Kurtosis: {kurtosis}")

fig, ax = plt.subplots(figsize=(20, 10))

boxplot = ax.boxplot(data["duration_ms"],
                     vert=False,
                     patch_artist=True,
                     notch=True,
                     sym='ro'
                     )

colors = ['lightblue', 'lightgreen', 'lightcoral']
for patch, color in zip(boxplot['boxes'], colors):
    patch.set_facecolor(color)

plt.title('Box and Whisker Plot of Duration (ms)')
plt.xlabel('Duration (ms)')
ax.yaxis.grid(True)

ax.set_yticklabels(['Data'])

plt.show()

fig, axes = plt.subplots(2, 2, figsize=(20, 12))

print("Distribution to analyze the outliers on the mean values associated with different categorical values:")
sns.barplot(data=df1, x="playlist_genre", y="track_popularity", ax=axes[0, 0])
sns.barplot(data=df1, x="playlist_genre", y="loudness", ax=axes[0, 1])
sns.barplot(data=df1, x="playlist_genre", y="duration_ms", ax=axes[1, 0])
sns.barplot(data=df1, x="playlist_genre", y="tempo", ax=axes[1, 1])

plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

data.head()

#Probability Distributions

grouped_column = 'playlist_genre'
unit_sales_column = 'track_popularity'
threshold_value = 70  # Set your desired threshold value

# Grouping the data by the 'playlist_genre'
grouped_data = data.groupby(grouped_column)

# Calculate the probability that unit sales are higher than the threshold value for each group
probability_data = grouped_data[unit_sales_column].apply(lambda x: (x > threshold_value).mean())

# Create a DataFrame with the resulting probabilities
result_df = pd.DataFrame({grouped_column: probability_data.index, 'Probability': probability_data.values})

# Print the resulting DataFrame with probabilities
print(result_df)

print("Histogram showing the probablity")
sns.histplot(probability_data)
plt.show()

increased_duration_count = len(data[data['duration_ms'] > data['duration_ms'].shift(1)])
total_data_points = len(data)

probability_increase = increased_duration_count / total_data_points

print(f"Historical Probability of Increase in Duration (ms): {probability_increase:.2%}")

data['duration_ms'] = pd.to_numeric(data['duration_ms'], errors='coerce')
data['duration_ms'].fillna(0, inplace=True)
increased_duration = data['duration_ms'] > data['duration_ms'].shift(1)

cumulative_probabilities = increased_duration.cumsum() / (increased_duration.index + 1)

plt.figure(figsize=(10, 6))
plt.plot(data.index, cumulative_probabilities, label='Cumulative Probability of Increase in Duration (ms)')
plt.xlabel('Data Points')
plt.ylabel('Cumulative Probability')
plt.title('Historical Cumulative Probability of Increase in Duration (ms)')
plt.grid(True)

plt.show()